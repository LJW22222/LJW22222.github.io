---
title: CPU[Register]
date: 2024-02-05 22:53:00 +0800
categories: [CS, OS]
tags: [CS, OS, Register]
---
# Register
레지스터는 CPU내부에 위치해있는 매우 빠른 속도의 작은 기억장치 입니다.  
주로 데이터를 일시적으로 저장하는데에 사용됩니다.  

CPU내부에는 많은 레지스터가 존재하는데, 이는 CPU마다 이름, 크기, 종류가 매우 다양합니다.  

하지만 이 많은 CPU에서도 공통으로 포함하는 레지스터가 존재합니다.  

이에 대해 알아보겠습니다.

## Register 종류
### 프로그램 카운터
메모리에서 가져올 명령어 주소를 저장하는 레지스터 입니다.  
즉, 메모리에서 읽어 들일 명령어의 주소를 저장합니다.  

### 명령어 레지스터
해석할 명령어를 저장하는 레지스터 입니다.  
즉, 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터 입니다.  
제어장치는 이 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보냅니다.  

### 메모리 주소 레지스터
이름 그대로 메모리의 주소를 저장하는 레지스터 입니다.  
CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 됩니다.  

## 메모리 버퍼 레지스터
메모리와 주고받을 값을 저장하는 레지스터입니다.  
즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거칩니다.  
CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거칩니다.

위의 4가지 레지스터에 대해 알아보았는데, 이들이 동작하는 동작 과정에 대해 알아보겠습니다.
### 동작과정
 ![register](/assets/img/cs/register.png){: width="650" height="400" }<br/> 
 먼저, CPU로 실행할 프로그램이 메모리에 저장되어있다고 가정하겠습니다. ( 1000번지부터 1500번지 )
 1. 프로그램이 처음부터 실행하기 위해 프로그램 카운터에는 1000번이 저장됩니다. 
 이는 메모리에서 가져올 명령어가 1000번지라는걸 의미합니다.
 2. 1000번지를 읽어 들이기 위해서는 주소 버스로 1000번지를 보내야 합니다. 이를 위해 메모리 주소 레지스터에는 1000이 저장됩니다.
 3. 메모리 읽기 라는 제어 신호와 주소 레지스터 값이 각각 제어버스와 주소 버스를 통해 메모리로 보내집니다.
   - 빨간선 - 메모리 주소 레지스터 -> 주소버스 -> 메모리
   - 파란선 - 제어장치 -> 제어버스 -> 메모리
 4. 메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 메모리를 읽어 들일 준비를 합니다 ( 1000 -> 1001 )
 5. 메모리 버퍼 레지스터에 저장된 값은 명렁어 레지스터로 이동합니다.
 6. 제어장치는 명령어 레스터의 명령어를 해석하고 제어 신호를 발생합니다.

 위의 과정을 메모리에 올라온 프로그램이 전부 실행될때까지 계속해서 반복합니다.

 위의 4가지 외에도 다른 4가지가 존재합니다.
 ## 범용 레지스터
 이름 그대로 다양한 상황에서 사용할 수 있는 레지스터입니다.  

 메모리 버퍼 레지스터에는 데이터 버스로 주고받을 값만 저장하고, 메모리 주소 레지스터에는 주소버스로 내보낼 값만 저장하지만,  

 범용 레지스터는 데이터와 주소 모두 저장할 수 있습니다.

 ## 플래그 레지스터
 연산결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터입니다.  

이처럼 여러가지 레지스터에 대해 알아보았는데, 이를 이용한 주소 지정 방식또한 존재합니다.  

## 특정 레지스터를 이용한 주소 지정 방식
### 스택 주소 지정 방식 [ 스택 포인터 ]
 스택과 스택 포인터를 이용한 주소 지정 방식입니다.  
 스택은 가장 최근에 저장한 값부터 꺼내는 방식입니다.
 이러한 방식을 LIFO 라고 합니다.
 
 스택포인터는 스택의 꼭대기를 가리키는 레지스터입니다.
 즉, 스택의 마지막으로 저장한 값의 위치를 지정하는 특별한 레지스터 입니다.  

 예를 들어서 1,2,3,4,5 순의 데이터가 스택에 담겨있으면 스택 포인터는 5를 가지고 있고, 여기서 데이터를 2개뺴고 난 1,2,3이 저장되있으면 스택 포인터는 3을 가지고 있게 됩니다.

 참고로 스택은 메모리 안에 있습니다.  
 즉, 메모리 안에 스택처럼 사용할 영역이 정해져있습니다. ( 스택영역 )

### 변위 주소 지정 방식
 명령어의 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식입니다.  

변위주소 지정방식의 명령어는 다음과 같이 구성되어 있습니다.  
 **| 연산코드 | 레지스터 | 오퍼랜드 |**

 이때 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등으로 나뉩니다.
### 상대 주소 지정 방식
 오퍼랜드와 프로그램 카운터 값을 더하여 유효 주소를 얻는 방식입니다.

 만약에 오퍼랜드가 음수, -5면, CPU는 읽어 들이기로한 명령어로부터 다섯번째 이전 번지를 실행합니다.  
 **프로그램 카운터 + ( -5 ) = 메모리 번지 주소**

 오퍼랜드가 양수 +5 이면 CPU는 읽어 들이기로한 명령어로부터 다섯번 건너뛴 번지를 실행하는 겁니다.  
 **프로그램 카운터 + 5 = 메모리 번지 주소**

 ### 베이스 레지스터 주소 지정 방식
 오퍼랜드와 베이스 레지스터 값을 더하여 유효 주소를 얻는 방식입니다.  

 여기서 베이스 레지스터는 기준주소, 오퍼랜드는 기준 주소로부터 떨어진 거리로서의 역할을 합니다.  

 즉, 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻는 방식입니다.

 베이스 레지스터에 200이라는 값이 있고, 오퍼랜드가 100이면,  
 " 기준 주소(200)로부터 100만큼 떨어진 300에 접근하라 " 를 의미합니다.  

 **오퍼랜드[떨어진 거리] + 베이스 레지스터[기준 주소] = 메모리 번지 주소**

 **참고 자료 :: 혼공자 [ 혼자 공부하는 컴퓨터 구조 + 운영체제 ]**  