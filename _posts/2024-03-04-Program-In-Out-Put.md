---
title: In/Out[Interrupt I/O]
date: 2024-03-04 15:48:00 +0800
categories: [CS, OS]
tags: [CS, OS, In/Out]
---
# 프로그램 입출력

프로그램 입출력은 기본적으로 프로그램 속 명령어로 입/출력 장치를 제어하는 방법입니다.   

한마디로 CPU가 프로그램 속 명령어를 실행하는 과정에서 입/출력 명령어를 만나면 CPU는 입출력 장치에 연결된 장치 컨트롤러와 상호 작용하여 입/출력 작업을 수행합니다.       

프로그램 입출력 과정을 알아보겠습니다.      

## 과정

### 1.
![Program_In_Out_1](/assets/img/In/Out/Program_In_Out_1.png){: width="550" height="300" }  

먼저 입/출력 장치와 관련된 명령어, 예를 들어서 하드 디스크에 새로운 정보를 써라 라는 명령어가 들어오면 CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 내보냅니다.     

### 2.

![Program_In_Out_2](/assets/img/In/Out/Program_In_Out_2.png){: width="550" height="300" }

하드 디스크 컨트롤러(장치 컨트롤러)는 하드 디스크(입/출력 장치)의 상태를 확인 하여 상태 레지스터에 정보를 기입 합니다.      

### 3.

![Program_In_Out_3](/assets/img/In/Out/Program_In_Out_3.png){: width="550" height="300" }


CPU는 상태 레지스터를 주기적으로 확인하여 하드 디스크(입/출력 장치)의 준비 여부를 확인합니다. 

하드 디스크가 준비됐음을 CPU가 확인하면 백업할 메모리의 정보를 데이터 레지스터에 작성합니다.  

아직 백업 작업이 끝나게 되면 작업을 종료합니다.  

여기서 의문점이 하나 존재합니다. 

CPU는 마치 외부에 있는 레지스터의 주소를 알고 있는 것처럼 행동을 하고 있습니다.

하지만 CPU는 내부의 레지스터가 아닌 외부에 존재하는 레지스터의 주소를 모두 알고 있기란 어렵습니다.  

그러나 CPU가 입/출력 장치들의 주소를 아는 방법은 크게 2가지 방법이 존재합니다. 

## 메모리 맵 입출력

![Memory_Map_In_Out](/assets/img/In/Out/Memory_Map_In_Out.png){: width="550" height="300" }

메모리 맵 입출력은 메모리에 접근하기 위한 주소 공간과 입/출력 장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법입니다.          

예를 들어서 512개의 주소를 표현할 수 있는 컴퓨터가 존재 할 때, 512개 전부 메모리 주소를 표현하는데 사용하지 않습니다.       

256개는 메모리 주소를 표현하고,나머지 256개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용합니다.      

여기서 중요한 점은 CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯이 하면 된다는 점 입니다.       

이로 인해 메모리에 접근하는 명령어와 입/출력 장치에 접근하는 명령어는 크게 다른 점이 없습니다.      

## 고립형 입출력

![Out/Isolated_In_Out_1](/assets/img/In/Out/Isolated_In_Out_1.png){: width="550" height="300" }

![Out/Isolated_In_Out_2](/assets/img/In/Out/Isolated_In_Out_2.png){: width="550" height="300" }

메모리 맵 입출력은 주소 공간을 하나의 주소 공간으로 간주하는 방법이었다면 고립형 입출력은 메메모리를 위한 주소 공간, 입/출력을 위한 주소 공간을 분리하는 방법입니다.  

위의 그림처럼 메모리 읽기/쓰기 선 이외에 입/출력 장치 읽기/쓰기 선이 따로 있다면, 메모리에도 512개의 주소 공간을 활용하고, 입/출력 장치에도 512개의 주소 공간을 활용할 수 있습니다.  

CPU가 메모리 읽기/쓰기 선이 활성화 되는 명령어를 실행할 경우에는 메모리에 접근하고, 입/출력 장치 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 장치 컨트롤러에 접근하기 때문입니다.

이로 인해 고립형 입/출력 방식에서는 CPU는 입/출력 장치에 접근하기 위해 메모리에 접근하는 명령어와는 다른 입/출력 명령어를 사용합니다. 

## 결론

메모리 맵 입출력과 고립형 입출력은 각각의 장단점이 존재합니다