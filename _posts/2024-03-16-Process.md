---
title: Process
date: 2024-03-16 18:32:00 +0800
categories: [CS, OS]
tags: [OS, CS]
---
# 프로세스
프로그램은 실행되기 전까지는 그저 보조기억장치에 있는 데이터 덩어리일 뿐이지만, 보조기억 장치에 저장된 프로그램을 메모리에 적재하고 실행하는 순간 이 프로그램은 프로세스가 됩니다.  

즉, 프로세스는 메모리에 프로그램이 적재되어 실행중인 프로그램을 말합니다.  

컴퓨터를 부팅하면 많은 프로그램이 메모리에 적재되어 수많은 프로세서들이 실행됩니다.  

이중, 사용자가 보는 앞에서 실행되는 프로세스는 포그라운드 프로세스라고 불리고, 사용자가 보지 못하는 뒤에서 실행되는 프로세스를 백그라운드 프로세스라고 합니다.

## 프로세스 제어 블록( PCB )

저번 포스터에서 말했듯이, 모든 프로세스는 실행을 위해 CPU를 필요로 하지만, 모든 컴퓨터 자원은 한정되어 있습니다.  

그렇기에 프로세서들은 차례대로 돌아가며 한정된 시간만큼만 CPU를 이용합니다.  

그러고 나서 시간이 다됬음을 알리는 인터럽트가 발생하면 차례를 양보하고 다시 또 차례를 기다립니다.  

이렇게 운영체제는 빠르게 번갈아 수행되는 프로세서의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분합니다.  

이때 운영체제는 프로세스 제어 블록(PCB)를 이용합니다.

프로세스 제어 블록은 프로세스와 관련된 정보를 저장하는 자료 구조 입니다.  

또한 프로세스 제어 블록은 커널영역에 생성됩니다. 

프로세스 제어 블록은 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기됩니다.  

이런 프로세스 제어 블록에는 다음과 같은 정보들이 저장되어있습니다.

## PCB 자료 구조

![pcb](/assets/img/os/Process/pcb.png){: width="550" height="300" }  

### 프로세스 ID

프로세스 ID ( PID )는 특정 프로세스를 식별하기 위해 부여하는 고유 번호입니다. 

같은 일을하는 프로그램이라도 PID가 다른 두 개의 프로세서가 생성됩니다.  

### 레지스터 값

프로세스가 실행하며 사용했던 프로그램 카운터를 비롯하여 레지스터 값들이 담깁니다.  

자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원합니다.  

그래야 이전까지 진행했던 작업들을 이어서 실행할 수 있습니다.

### 프로세스 상태

현재 프로세스가 입/출력 장치를 사용하기 위해 기다리고 있는 상태인지, CPU를 사용하기 위해 기다리고 있는 상태인지 등 프로세스 상태 정보가 PCB에 저장됩니다.

### CPU 스케쥴링 정보

프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보도 PCB에 기록됩니다.

### 메모리 관련 정보

프로세스마다 메모리에 저장된 위치가 다르기 때문에 PCB에 프로세스가 어느 주소에 저장되어 있는지에 대한 정보도 있어야 합니다.  

그래서 PCB에는 베이스 레지스터, 한계 레지스터 값과 같은 정보들이 담깁니다.

또한 페이지 테이블 정보도 담깁니다.

### 사용한 파일과 입출력장치 목록

프로세서가 실행 과정에서 특정 입/출력 장치나 파일을 사용하면 PCB에 해당 내용이 명시됩니다.

## 문맥교환

![Context-switching](/assets/img/os/Process/Context-switching.png){: width="550" height="300" }  

예를 들어서 프로세스 A가 운영체제로 부터 CPU를 할당받아 실행되다가 시간이 다되어 프로세스 B에 CPU를 양보한다고 가정하겠습니다.  

이런 상황이오면 프로세스 A는 프로그램 카운터를 비롯한 레지스터 값, 메모리 정보 등 지금까지의 중간 정보를 백업해야합니다.  

이때 이러한 중간정보를, 즉 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보를 문맥이라고 합니다.

참고로 하나의 프로세스 문맥은 해당 프로세스 PCB에 기록되어 있습니다.

이처럼 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로 부터 복구하여 새로운 프로세스를 실행하는 것을 문맥교환이라고 합니다.

![Context-switching-2](/assets/img/os/Context-switching-2.png){: width="550" height="300" }  

문맥 교환은 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리입니다.

참고로 문맥 교환이 너무 일어나면 오버헤드가 발생할 수 있기 때문에 무작정 많이 일어나는건 좋지 않습니다.

## 프로세스 메모리 영역

![process-memory-area](/assets/img/os/Process/process-memory-area.png){: width="550" height="300" }  

프로세스는 생성이되면 커널영역에 PCB가 생성이 됩니다.  

그렇다면 사용자 영역에 프로세스가 배치되는데, 이 사용자 영역에 대해서 좀 더 알아보겠습니다.

참고로 코드 영역, 데이터 영역은 크기가 고정된 영역이라 **정적 할당 영역**이라고도 하고, 힙, 스택 영역은 크기가 변하는 영역이라 **동적 할당 영역**이라고도 부릅니다.

### 코드 영역

실행할 수 있는 코드, 즉 기계어로 이루어진 명령어가 저장됩니다.  

코드 영역은 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 읽기 전용 공간으로 설정이 되어 있습니다.

### 데이터 영역

잠깐 사용했다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간입니다.  

이런 데이터는 전역 변수가 대표적입니다.

### 힙 영역

프로그래머가 직접 할당할 수 있는 저장 공간입니다.  

힙 영역에 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야 합니다.

만약 메모리 공간을 반환하지 않는다면 이 공간은 메모리 내에 계속 남아 메모리 낭비를 초래합니다.  

이런 문제를 바로 메모리 누수라고 합니다.

### 스택 영역

데이터를 일시적으로 저장하는 공간입니다.  

즉, 데이터 영역과는 달리 잠깐 쓰다가 없어질 값들이 저장되는 공간입니다.

예를 들어서 함수의 실행이 끝나면 사라지는 매개 변수, 지역 변수가 대표적입니다.