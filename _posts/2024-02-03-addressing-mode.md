---
title: 명령어[주소지정방식]
date: 2024-02-03 22:19:00 +0800
categories: [CS, OS]
tags: [CS, AddressingMode]
---
# 주소 지정 방식
 명령어는 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 경우가 많습니다.  
 그래서 오퍼랜드 필드를 주소 필드기라도 부르기도 합니다.  

 오퍼랜드에 메모리나 레지스터의 주소를 담는 이유는 명령어의 길이 떄문입니다.  

 예를 들어서 하나의 명령어가 n비트로 구성되어 있고, 그중 연산 코드 필드가 m이라고 가정해보겠습니다.  

 오퍼랜드 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어라 할지라도 오퍼랜드 필드의 길이는 연산 코드만큼의 길이를 뺸 n-m비트가 됩니다.  

 2-주소 명령어, 3-주소 명령어라고 하면 오퍼랜드 필드의 크기는 더욱 작아집니다.
 이런 이유로 레지스터나 메모리의 주소를 오퍼랜드에 담아야합니다.  

 이렇듯 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때, 연산에 사용할 데이터 위치를 찾는 방법을 주소 지정 방식이라고 합니다.  

## 즉시 주소 지정 방식
### **| 연산코드 | 연산에 사용할 데이터**

 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방법입니다.  

 가장 간단한 형태의 주소 지정방식이긴 하나 데이터의 크기가 작아진다는 단점이 있습니다.  

 하지만, 연산에 사용할 데이터를 메모리나 레지스터로부터 찾아오는 과정이 없기에 빠른 속도를 가지고 있습니다.

## 직접 주소 지정 방식
 ![direct-addressing-mode](/assets/img/cs/direct-addressing-mode.png){: width="550" height="300" }<br/> 
 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방법입니다.  
 즉시 주소 지정 방식보다는 필드에 표현이 가능한 데이터의 크기가 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드 비트 수 만큼 줄었습니다.  

 즉, 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 있습니다.

## 간접 주소 지정 방식
 ![indirect-addressing-mode](/assets/img/cs/indirect-addressing-mode.png){: width="550" height="300" }<br/>
 유효 주소의 주소를 오퍼랜드 필드에 명시합니다.  
 즉, 메모리의 유효주소의 주소를 명시하는 방식입니다.  

 표현이 가능한 유효 주소의 범위가 넓어졌지만, 메모리에 두번의 접근이 필요하기 때문에 일반적으로 느린 방식입니다.  

## 레지스터 주소 지정 방식
 ![register-addressing-mode](/assets/img/cs/register-addressing-mode.png){: width="550" height="300" }<br/>
 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법입니다.  

 레지스터는 CPU의 내부에 존재하기 때문에 메모리에 접근하는 것보다 레지스터에 접근하는 것이 더 빠릅니다.  

 하지만, 표현할 수 있는 레지스터 크기에 제한이 생길수 있는 점이 단점입니다.  

## 레지스터 간접 주소 지정 방식
  ![register-addressing-mode](/assets/img/cs/register-indirect-addressing-mode.png){: width="550" height="300" }<br/>
  연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법입니다.  

  간접 주소 지정 방식보다 메모리에 접근하는 횟수가 한번이고, 또한 레지스터에 접근하기 때문에 빠른 속도가 장점입니다.  

**참고 자료 :: 혼공자 [ 혼자 공부하는 컴퓨터 구조 + 운영체제 ]**  